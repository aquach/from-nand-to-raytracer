class Scene {
  field int width;
  field int height;
  field Array elements;
  field int nElements;
  field Array lights;
  field int nLights;

  constructor Scene new(int w, int h, Array e, int ne, Array l, int nl) {
    let width = w;
    let height = h;
    let elements = e;
    let nElements = ne;
    let lights = l;
    let nLights = nl;
    return this;
  }

  method void dispose() {
    var int i;
    var Element e;
    var Light l;

    let i = 0;
    while (i < nElements) {
      let e = elements[i];
      do e.dispose();
      let i = i + 1;
    }
    do elements.dispose();

    let i = 0;
    while (i < nLights) {
      let l = lights[i];
      do l.dispose();
      let i = i + 1;
    }
    do lights.dispose();

    do Memory.deAlloc(this);

    return;
  }

  method int getWidth() {
    return width;
  }

  method int getHeight() {
    return height;
  }

  method Array getElements() {
    return elements;
  }

  method int getNumElements() {
    return nElements;
  }

  method Array getLights() {
    return lights;
  }

  method int getNumLights() {
    return nLights;
  }

  method Ray create_prime_ray(int pixel_x, int pixel_y) {
    var Number scene_width;
    var Number scene_height;
    var Number one;
    var Number two;
    var Number half;

    var Number aspect_ratio;
    var Number sensor_x;
    var Number sensor_y;
    var Vec3 direction;

    let scene_width = Number.new(width);
    let scene_height = Number.new(height);

    let one = Number.new(1);
    let two = Number.new(2);

    let half = Number.new(1);
    do half.do_div(two);

    let aspect_ratio = scene_width;
    do aspect_ratio.do_div(scene_height);

    let sensor_x = Number.new(pixel_x);
    do sensor_x.do_add(half);
    do sensor_x.do_div(scene_width);
    do sensor_x.do_mul(two);
    do sensor_x.do_sub(one);
    do sensor_x.do_mul(aspect_ratio);

    let sensor_y = Number.new(pixel_y);
    do sensor_y.do_add(half);
    do sensor_y.do_div(scene_height);
    do sensor_y.do_neg();
    do sensor_y.do_mul(two);
    do sensor_y.do_add(one);

    let direction = Vec3.new(
        sensor_x,
        sensor_y,
        Number.new(-1)
        );
    do direction.do_normalize();

    do scene_width.dispose();
    do scene_height.dispose();
    do one.dispose();
    do two.dispose();
    do half.dispose();

    do aspect_ratio.dispose();
    do sensor_x.dispose();
    do sensor_y.dispose();

    return Ray.new(
        Vec3.new(
          Number.new(0),
          Number.new(0),
          Number.new(0)
          ),
        direction
        );
  }

  method Intersection trace(Ray ray) {
    var Intersection intersection;
    var int i;
    var Element elem;
    var Number distance;
    var Number cur_distance;

    while (i < nElements) {
      let elem = elements[i];
      let distance = elem.intersect(ray);

      if (~(intersection = null)) {
        let cur_distance = intersection.getDistanceFromOrigin();
      }

      if ((~(distance.is_negative())) & (intersection = null | cur_distance.is_less_than(distance))) {
        if (~(intersection = null)) {
          do intersection.dispose();
        }
        let intersection = Intersection.new(distance, elem);
      } else {
        do distance.dispose();
      }

      let i = i + 1;
    }

    return intersection;
  }
}
