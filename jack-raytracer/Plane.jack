// One-sided plane.
class Plane {
  field Vec3 origin;
  field Vec3 normal;
  field Number color;
  field boolean checkerboarded;

  constructor Plane new(Vec3 o, Vec3 n, Number c, boolean ch) {
    let origin = o;
    let normal = n;
    let color = c;
    let checkerboarded = ch;
    return this;
  }

  method void dispose() {
    do origin.dispose();
    do normal.dispose();
    do color.dispose();
    do Memory.deAlloc(this);
    return;
  }

  method Number intersect(Ray ray) {
    var Number denom;
    var Vec3 ray_to_origin;
    var Number distance;

    let denom = normal.dot(ray.getDirection());

    if (~denom.is_positive()) {
      do denom.dispose();
      return Number.new(-1);
    }

    let ray_to_origin = origin.clone();
    do ray_to_origin.do_sub(ray.getOrigin());

    let distance = ray_to_origin.dot(normal);
    do distance.do_div(denom);

    do denom.dispose();
    do ray_to_origin.dispose();

    if (~distance.is_negative()) {
      return distance;
    } else {
      do distance.dispose();
      return Number.new(-1);
    }
  }

  method Vec3 color(Vec3 hit_point) {
    var Vec3 x_axis;
    var Vec3 forward;
    var Vec3 up;
    var Vec3 y_axis;
    var Number dist_sq;

    var Number scale;
    var Number v;
    var Int32 x;
    var Int32 y;
    var Number sum;
    var Number halftwice;
    var Number n;

    var Number thousand;
    var Number hundred;
    var Int32 two;

    if (checkerboarded) {
      let thousand = Number.new(1000);
      let hundred = Number.new(100);
      let two = Int32.new(2);

      let x_axis = normal.clone();
      let forward = Vec3.new(
          Number.new(0),
          Number.new(0),
          Number.new(1)
          );
      let up = Vec3.new(
          Number.new(0),
          Number.new(1),
          Number.new(0)
          );
      do x_axis.do_cross(forward);

      let dist_sq = x_axis.dist_sq();
      if (dist_sq.is_zero()) {
        do x_axis.do_cross(up);
      }

      let y_axis = normal.clone();
      do y_axis.do_cross(x_axis);

      let scale = Number.new(1);

      let v = hit_point.dot(x_axis);
      do v.do_mul(scale);
      do v.do_add(thousand);
      let x = v.to_int32();

      let v = hit_point.dot(y_axis);
      do v.do_mul(scale);
      do v.do_add(thousand);
      let y = v.to_int32();

      let sum = x.clone();
      do sum.do_add(y);

      let halftwice = sum.clone();
      do halftwice.do_div(two);
      do halftwice.do_mul(two);

      if (sum.cmp(halftwice) = 0) {
        let n = Number.new(90);
      } else {
        let n = Number.new(3);
      }

      do n.do_div(hundred);

      do x_axis.dispose();
      do forward.dispose();
      do up.dispose();
      do y_axis.dispose();
      do dist_sq.dispose();

      do scale.dispose();
      do x.dispose();
      do y.dispose();
      do sum.dispose();
      do halftwice.dispose();

      do thousand.dispose();
      do hundred.dispose();
      do two.dispose();

      return n;
    } else {
      return color.clone();
    }
  }

  method Vec3 surface_normal() {
    var Number neg1;
    var Vec3 c;

    let neg1 = Number.new(-1);

    let c = normal.clone();
    do c.do_scale(neg1);
    do neg1.dispose();
    return c;
  }
}
